(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{379:function(t,v,_){"use strict";_.r(v);var e=_(44),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"简单陈述异步的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单陈述异步的理解"}},[t._v("#")]),t._v(" 简单陈述异步的理解")]),t._v(" "),_("h4",{attrs:{id:"简单理解什么是异步"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单理解什么是异步"}},[t._v("#")]),t._v(" 简单理解什么是异步")]),t._v(" "),_("p",[t._v("首先 JS 一定是"),_("code",[t._v("单线程")]),t._v("的，为什么是单线程呢，因为JS的终极目的还是为了操作DOM，实现用户交互。假设JS是多线程的，当两个线程同时操作同一个DOM的时候，没法处理，矛盾了。")]),t._v(" "),_("p",[t._v("既然是单线程，也就引发了一个问题，那就是"),_("code",[t._v("阻塞")]),t._v("。什么叫阻塞，假设JS的代码永远是同步的，当前面的一段代码耗时很久的时候，后面的代码岂不是要一直等前面的代码执行完才能执行，这就会造成页面十分的卡顿，因此有了异步")]),t._v(" "),_("p",[t._v("所谓异步，就是先不进入JS的"),_("code",[t._v("主线程")]),t._v("执行，而是先进入"),_("code",[t._v("任务队列")]),t._v("，当主线程的任务执行完了，再拿出来进入主线程执行。")]),t._v(" "),_("h4",{attrs:{id:"常见的异步任务-常见的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见的异步任务-常见的"}},[t._v("#")]),t._v(" 常见的异步任务（常见的）")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("事件监听：javascript各种事件的执行都是异步任务")])]),t._v(" "),_("li",[_("p",[t._v("setTimeout、setInterval 定时器")])]),t._v(" "),_("li",[_("p",[t._v("Ajax")])]),t._v(" "),_("li",[_("p",[t._v("MutationObserver 创建并返回一个新的 MutationObserver 它会在指定的DOM发生变化时被调用。")])]),t._v(" "),_("li",[_("p",[t._v("Promise")])]),t._v(" "),_("li",[_("p",[t._v("async function")])])]),t._v(" "),_("p",[t._v("这块涉及到事件循环和宏任务、微任务之类的")]),t._v(" "),_("p",[t._v("先简单的记一下 执行执行循序：")]),t._v(" "),_("p",[_("code",[t._v("同步 > 宏观 > 微观")])]),t._v(" "),_("p",[t._v("问到的话再给你细讲，感觉一般的不会问")])])}),[],!1,null,null,null);v.default=a.exports}}]);