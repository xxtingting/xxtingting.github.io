(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{397:function(t,e,a){"use strict";a.r(e);var v=a(44),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"computed-和-watch-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别"}},[t._v("#")]),t._v(" computed 和 watch 的区别")]),t._v(" "),a("p",[a("code",[t._v("computed")]),t._v(" （计算属性）")]),t._v(" "),a("ul",[a("li",[t._v("依赖于某些值返回一个值，可以设置get和set方法")]),t._v(" "),a("li",[t._v("有缓存，依赖的值没有变化，那么不会重新计算")])]),t._v(" "),a("p",[a("code",[t._v("watch")]),t._v(" （监听属性）")]),t._v(" "),a("ul",[a("li",[t._v("监听一个值的变化，当被监听的值改变时，可执行相关动作")]),t._v(" "),a("li",[t._v("可设置深度监听，deep: true，用来监听多层对象")]),t._v(" "),a("li",[t._v("可设置立即执行，immediate: true，即组件初始化时立即执行被监听的值的相关动作")])]),t._v(" "),a("h4",{attrs:{id:"使用场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),a("p",[t._v("根据computed和watch的特点")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；")])]),t._v(" "),a("li",[a("p",[t._v("当我们需要在数据变化时执行某些操作时，应该使用 watch")])])])])}),[],!1,null,null,null);e.default=_.exports}}]);